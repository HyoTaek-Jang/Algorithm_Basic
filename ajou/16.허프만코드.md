효율적으로 저장하는 인코딩 기법 중 하나임.

### Data Compression

알파벳을 바이너리 캐릭터 코드로 인코딩함. 이러한 인코딩된 바이너리 코드를 코드워드라고 함.

#### Fixed-length code

각 알파벳에 고유한 코드를 부여함. a=000, b=001 이렇게.
프리퀀시(몇번 등장하는지)의 합이 10만개. 총 길이를 10만 \* 3 = 30만

이거보다 더 적은 비트를 사용해서 압축시키는게~ 허프만!

### Huffman codes

데이터가 픽스되있지 않음. 길이가 변화 할 수 이씅! 옵티멀한 인코딩 방법을 찾는 문제에 사용됨
허프만은 빈도수가 높은 알파벳을 0으로 인코딩함. 그리고 순차대로 101 100 111 이렇게 함.
하튼 가장 많이 쓰는 놈의 인코딩 길이를 줄임.

각 코드가 다른 코드의 프리픽스로 들어가는게 없음!! 어느코드도 서로서로 프리픽스가 아니면
prefix-free code라고 말함.

### 질문 :335쪽 저거 a,b 프리픽스 프리 코드가 아니지 않나

### building huffman codes

트리를 활용하고 바텀업 방식을 통해 만들어짐. 이렇게 서브트리를 만들고 컴바인해서 전체 트리를 만듦

C is set of n(6개) characters
each character는 프리퀀시를 가짐.

트리 T는 n리프노드에서 시작함. 각각의 리프 노드를 이용해서 n-1 머지 과정을 거침. 이렇게 트리가 만들어짐

이 과정에서 min-priority queue를 사용함. 프리퀀시를 활용해서 프리퀀시 낮은 캐릭터를 먼저 이용함. 가장 적은 프리퀀시를 갖는 놈 두개를 골라서 서브트리와 부모노드를 만듬. 그리고 두 자식의 프리퀀시의 합을 부모노드의 레이블 값으로 만듦.

무조건 왼쪽 엣지는 0, 오른쪽은 1로 엣지에 숫자를 매김.

캐릭터들은 다 리프노드여서 모호한 상황이 발생하지 않음.

min-heap이랑 min-priority-queue랑 같은거임
그리고 가장 작은걸 왼쪽에 그다음이 오른쪽에 달림. 그래서 항상 왼쪽이 더 작음

퍼포먼스 분석
min heap 만드는 시간 O(n)
loop는 1-n-1까지함.
min heap inserting (log n)
따라서 러닝타임 = O(n log_n )

어떤 그리디한 특성이 있는가
: 가장 프리퀀시가 적은 캐릭터에게 가장 긴 패스를 줌

옵티멀 서브스트럭쳐
: 적은 비트를 사용해서 인코딩이 되면 그게 옵티멀 솔루션
