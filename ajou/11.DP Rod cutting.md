우리가 찾는 옵티멀 솔루션은 서브프러블럼의 옵티멀 솔루션 또한 갖고 있어야 한다.
옵티멀한 서브 스트럭쳐가 설계되면 이거로 리커런스를 만들고 테이블을 제작하고 문제에 솔루션을 찾음

dp는 반복적인 계산에서 편리함

# 이항계수 구하기

파스칼의 삼각형

1C0 = 0, 1C1 = 1
2C1 = 1C0 + 1C1
3C2 = 2C1 + 2C2 이런식

fucn C(n,k)
if k=0 or k=n then
return 1
else
return C(n-1, k-1) + C(n-1, k)

위처럼 리컬시브하게 탑다운 방식으로 하면 2^n이 나옴
높이가 n이고 넓이가 2n씩 증가함
근데 같은 계산을 계속함

DP를 쓰면 nk가 나옴.

# Rod cutting problem

파이프를 잘랐을 때 가장 큰 이득을 얻을 수 있게!
테이블에 각 길이마다 가격이있음.
한정된 길이가 있을 때 어떻게 잘라야 제일 비싸게 돈을 받나

매순간마다 자를까 말까 2가지 선택지가 있음. 이걸 n-1까지 선택하면 됨
따라서 2^(n-1)

ri는 i파이프에 맥시멈 값

max(Pn, r1+rn-1, r2+rn-2...rn-1+r1)

### Optimal substructure

옵티멀한 서브스트럭쳐의 특징을 찾아서, 전체 문제의 옵티멀 솔루션이 서브프라블럼 옵티멀 솔루션을 포함하게!

각각 파이프에 대해 솔루션이 적용됨.

서브문제를 해결하고 계속 키우는거임
max(Pn, r1+rn-1, r2+rn-2...rn-1+r1)

n짜리 길이가 주어지면 맨 왼쪽에서부터 자름. 그러면 2개의 서브 문제가 생김. 이 두개에 대해 옵티멀한 이득을 찾음.
-> 보다 심플하게, 파이프를 자를때, 왼쪽에서 n만큼 자르면 오른쪽은 자동으로 k-n임. 오른쪽 파이프를 서브 프러블럼의 인풋으로 사용해서 옵티멀한 답을 찾아가자!

리컬시브하게, dp로 둘다 풀 수 있음.

리컬시브는 반복 계산이 많아서 비효율적임.

런타임을 분석하라는 말은 점화식 T(n)을 계산해서 알고리즘의 런타임이 big of ~~다 라고 말해야 런타임 분석임

리컬시브는 2^n임

반복게산될걸 테이블에 저장해서 필요할때 가져와서 샤용하는! 디피 방법, 바텀업 방식으로!
작은 문제를 계산하고 그 값을 계속 활용하는!

max(q, p[i]+r[j-i]), 디피는 테이블을 채워넣는 러닝타임만 계산하면됨 포문만 ㅇㅇ! n^2이 나오네용
근데 최대 이득에 더하여 어떻게 잘랐는지도 알아야함 단순히 r[i]뿐만 아니라!

최대가 되는 i를 기록하면 됨

강의노트 참고

---
