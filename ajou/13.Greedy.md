# Greedy

우리가 배운거

1. 디바이드 앤 퀀커 : 디바이드, 퀀커, 컴바인의 과정. 어떤 문제를 스몰러한 서브 문제로 나눔(완전독립)
2. 디피 : 전체 문제를 스몰러하게 나누는데 전체문제와 연관이있어서 작은 문제를 푼게 큰 문제와 연관됨. 옵티멀한 서브스트럭쳐를 꼭 만족해야함.

디피가 옵티마이즈에 적합함
그리디도 옵티마이즈에 적합함.
얘는 현재 순간에 최고의 선택을 함. locally optimal, i don't know it's globaly optimal

디피는 이전 결과를 활용해서 더 큰 문제의 옵티멀 솔루션을 찾았다면
그리디는 순간마다 최고의 선택을 함.

### Greedy

set of candidates
옵티멀 솔루션이 될만한 후보군을 모아서 솔루션 셋을 만듬.
그리고 이게 옵티멀이 되는지 체크하는 과정이 필요함.
초기로 엠티 셋임.

1. Selection procedure
   좋아보이는거 set of candidates에 넣음
2. Feasibility check
   적합함을 체크. 이 셋이 문제 조건에 만족하는지!
   통과 안되면 1번으로 회귀
3. solution check
   통과되면 일로와서 솔루션 확인.
   통과되면 끝!
   안되면 1번

### Activity selelction

n개의 액티비티가 주어짐.
각각 액티비티가 강의장소를 사용하기 위한 시간이 있음
강의 일정을 조율하기 위해 n개 액티비티를 배치할지..!
n개 액티비티는 리소스 정보를 갖고있음. 언제 시작에서 끝나는지
리소스들이 서로 오버랩 안되게 스케줄링하는 문제

골 : 액티비티가 서로 최대한 안겹치게 커버하는 largest possible set of activities

인풋 n개 액티비티(스타트 피니쉬 시간이 있는), 아웃풋 largest set(오버래핑 없이!)

[ ] 이상 이하
( ) 초과 미만

분리된 액티비티를 compatible하다고 말함

계속 겹치지 않는 선에서 빨리 끝나는걸 고르는게 가장 효과적일 거임!

### 디피적 사고

해당 액티비티를 선택할건지 말건지 선택의 연속
S_ij 는 전체문제임 ㅇㅇ

S_ij 는 a_1가 끝나고 시작하고 a_j가 시작하기 전에 끝나는! 액티비티의 집합
S_ij, 0<= i < j <= n+1
S_ij에 a_k가 포함되있으면 두개의 서브프라블럼으로 나눌수있음.

솔루션 : S_ik + a_k + S_kj

따라서 S_ij는 S_ik, S_kj로 나눌 수 있고 저 두 문제 또한 옵티멀 솔루션이여야함

테이블 채우기 : c[i,j] = S_ij
따라서 c[i,j] = c[i,k] + 1 + c[k,j]
