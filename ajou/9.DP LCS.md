# DP

알고리즘 문제를 해결하는 기법 중 하나임. 디바이드 퀀커, 그리디 같은!

서브프러블럼을 만들어서 풀어나가면서 전체 문제를 푸는거임!

바텀업 어프로치 -> 이전에 계산한 작은 사이즈의 문제로 더 큰 문제를 푸는거임

작은 사이즈의 문제를 풀어서 테이블에 저장하고 더 큰 문제를 풀때 이미 저장된 테이블의 작은 문제 답을 이용해서 큰 문제의 솔루션을 찾아감.
테이블에 이미 계산한 서브 문제 답을 적어놔서 중복 계산을 하지 않음

optimization problems은 여러 해결 방법이 있을 수 있음. 근데 그 중 가장 최적의 자원을 사용해서 쓰는거지~

## 디바이드 앤 컨쿼, 디피

둘다 작은 문제를 나누는건 비슷하다.
디바이드는 완전히 분리된 두 문제로 나눔. 컴바인의 개념
디비는 문제들이 서로 연관됨(두 문제가 겹친다.) 빌드업의 개념.

## DP 4steps

1. 옵티멀 솔루션이 갖는 구조적 특성을 캐릭터라이즈함.
2. 반복적으로 옵티멀 솔루션의 값을 정의함.
3. 설계된 점화식을 보고 각 서브 문제의 옵티멀한 값을 계산, 테이블의 값들을 채워나감.
4. 최종적으로 옵티멀 솔루션을 계산함

### The longest common subsequence

- 생물학적으로 두 DNA 시퀀스의 유사성을 계산할때 적용됨
  서브스트링이 유사하면 유사하다
  조금만 변화해서 같아지면 유사하다
  S1,S2에 S3가 들어가있다. 그러면 S1,S2는 유사하다.

### subsequence

꼭 연속될 필요는 엄슴!
서브시퀀스는 오더가 유지되야함.

### common subsequence

Z가 X, Y에 서브시퀀스면
Z는 커먼 서브시퀀스

### 접근법

naive approach : 한쪽의 서브시퀀스를 다 구하고 나머지 쪽의 서비시퀀스가 되는지 확인

X4 = <A,B,C,D> 이런식으로 i번째 프리픽스는 서브시퀀스로 표현가능

## DP 4steps

1. 옵티멀 솔루션이 갖는 구조적 특성을 캐릭터라이즈함.
   옵티멀 서브스트럭쳐란 전체 오리지널 문제에 대한 옵티멀 솔루션이 서브문제의 옵티멀 솔루션을 포함하는것
2. 반복적으로 옵티멀 솔루션의 값을 정의함.
   서브프러블럼의 옵티멀한 솔루션을 계산. 반복적으로!
3. 설계된 점화식을 보고 각 서브 문제의 옵티멀한 값을 계산, 테이블의 값들을 채워나감.
   작은 i,j로 시작해서 테이블을 채워나감.
4. 최종적으로 옵티멀 솔루션을 계산함

### LCS의 옵티멀 서브스트럭쳐

### cost of optimal solution

커먼 서브시퀀스의 가장 긴 길이를 비교하고자 하는 옵티멀 솔루션 값으로 정의함.
그래서 매 순간마다 옵티멀한 값을 c[i,j]에 저장하면됨 베이스 케이스는 0

c[i,j] =
if i=0 j=0 : 0 // empty셋이기에
if i,j>0 and xi = yi: c[i-1,j-1]+1
if i,j>0 and xi != y1: max(c[i-1,j],c[i,j-1])

### Optimal substructure

case 1 Xm != Yn

1. Zk != Yn -> Z is an LCS of Xm and Yn-1
2. Zk != Xm -> Z is an LCS of Xm-1 and Yn

case 2 Xm = Ym
마지막 값이 같으면 둘이 같기에 LCS에 포함됨 그래서 둘다 빼버리고 옵티멀한 LCS 값을 구함

### recursive approach for LCS

n = x길이, m = y길이
top down, 2^(n+m)
같은경우가 1개도 없으면 ㅇㅋ? 근데 한개만 0되도 끝이니까 -> 2^n. n이 더 짧음

### Dp for LCS

디피는 테이블에 적으면서 작은 크기에서 점점 커지는거지. 빌드업

수도코드는 강의노트 참고!

테이블 만드는 런타임은 m\*n
프린트하는 시간은 m+n

1. 옵티멀한 서브스트럭쳐 찾기
2. 서브스트럭쳐를 활용해서 리커런스(점화식)를 설계.
3. 테이블을 만들고 바텀업 방식으로 빌드업.
4. 빌드업이 되면 완성된 값으로 옵티멀한 값 찾기

```
최장 공통 부분수열(Longest Common Subsequence) 찾기
위에서 LCS 구현과정을 통해 LCS 배열을 만들며 LCS의 길이를 알았습니다. 이제 만든 LCS 배열을 이용해 최장 공통 부분수열의 값을 찾아보겠습니다. 경우에 따라 여러가지 답이 나올 수 있기 때문에 아래 예시는 한가지 경우만을 보겠습니다.

과정은 다음과 같습니다.

LCS 배열의 가장 마지막 값에서 시작합니다. 결과값을 저장할 result 배열을 준비합니다.
LCS[i - 1][j]와 LCS[i][j - 1] 중 현재 값과 같은 값을 찾습니다.
2-1. 만약 같은 값이 있다면 해당 값으로 이동합니다.
2-2. 만약 같은 값이 없다면 result배열에 해당 문자를 넣고 LCS[i -1][j - 1]로 이동합니다.
2번 과정을 반복하다가 0으로 이동하게 되면 종료합니다. result 배열의 역순이 LCS 입니다.
```

https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence
